# 用户手册4.x

## 前言

### 问题

如今，我们使用通用应用程序或软件库来相互通信。例如，我们经常使用HTTP客户端软件库从web服务器检索信息并通过web服务执行远程过程调用（RPC）。然而，通用协议或其实现有时不能很好地扩展。这就像我们不能使用通用HTTP服务去交换大型文件、电子邮件、近实时消息（例如金融信息和多人游戏数据）一样。所需要的是专用于特殊目的的高度优化的协议实现。例如，您可能想要实现一个 HTTP 服务器，该服务器针对基于 AJAX 的聊天应用程序、媒体流或大文件传输进行了优化。您甚至可能想要设计和实现完全根据您的需要量身定制的全新的协议。另一个不可避免的情况是，您必须处理遗留的专有协议以确保与旧系统的互操作性。在这种情况下，重要的是我们可以多快地实施该协议，同时又不牺牲最终应用程序的稳定性和性能。

## 解决方案

Netty 致力于提供异步事件驱动的网络应用程序框架和工具，用于快速开发可维护的高性能和高可扩展性的服务器和客户端协议。

换句话说，Netty 是一个 NIO 客户端服务器框架，可以快速轻松地开发服务器和客户端协议等网络应用程序。它极大地简化和精简了 TCP 和 UDP Socket服务器开发等网络编程。

“快速而轻松”并不意味着生成的应用程序会遇到可维护性或性能问题。Netty 是根据从许多协议（例如 FTP、SMTP、HTTP 以及各种二进制和基于文本的遗留协议）的实现中学到的经验而精心设计的。最终，Netty 成功地找到了一种方法，可以在不妥协的情况下实现易于开发、性能、稳定性和灵活性。

一些用户可能已经发现其他声称具有相同优势的网络应用程序框架，您可能想知道是什么让 Netty 与它们如此不同。答案是它所建立的思想体系。Netty 从一开始被设计的目的就是在 API 和实现方面为您提供最舒适的体验。这不是有形的东西，但是当您阅读本指南并使用 Netty 时，您会意识到这种思想体系将使您的生活变得更加轻松。

## 入门

本章通过简单的示例来介绍 Netty 的核心结构以便让您快速入门。读完本章后，您将立刻能够使用Netty编写客户端和服务端。

如果您更喜欢自上而下的方法学习某件事情， 您可能希望从第 2 章架构概述开始，然后回到这里。

### 开始之前

运行本章示例的最低要求只有两个；最新版本的 Netty 和 JDK 1.6 或更高版本。最新版本的 Netty 可在[项目下载页面](https://netty.io/downloads.html)获得。要下载正确版本的 JDK，请参阅您首选的 JDK 供应商的网站。

在阅读时，您可能对本章介绍的类有一些疑问。每当您想了解有关它们的更多信息时，请参考 API 参考。为方便起见，本文档中的所有类名都链接到在线 API 参考。另外，请不要犹豫联系 [Netty 项目社区](https://netty.io/community.html)，如果有任何不正确的信息、语法错误或拼写错误，以及您是否有任何好主意来帮助改进文档，请告诉我们。

### 编写DISCARD服务器

世界上最简单的协议不是“Hello, World！” 而是**DISCARD**。它是一种丢弃任何接收到的数据而没有任何响应的协议。

要实现 DISCARD 协议，您唯一需要做的就是忽略所有接收到的数据。让我们直接从处理程序的实现开始，它处理由 Netty 生成的 I/O 事件。

```java
package io.netty.example.discard;

import io.netty.buffer.ByteBuf;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;

/**
 * Handles a server-side channel.
 */
public class DiscardServerHandler extends ChannelInboundHandlerAdapter { // (1)

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) { // (2)
        // 静默丢弃接收到的数据。
        ((ByteBuf) msg).release(); // (3)
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { // (4)
        // 引发异常时关闭连接。
        cause.printStackTrace();
        ctx.close();
    }
}
```

1. `DiscardServerHandler` 扩展了 [ChannelInboundHandlerAdapter](https://netty.io/4.1/api/io/netty/channel/ChannelInboundHandlerAdapter.html)，`ChannelInboundHandlerAdapter` 是 [ChannelInboundHandler](https://netty.io/4.1/api/io/netty/channel/ChannelInboundHandler.html) 的一个实现。`ChannelInboundHandler` 提供了可以重写的各种事件处理程序方法。目前，继承 `ChannelInboundHandlerAdapter` 就足够了，而不用自己实现 `ChannelInboundHandler`。
2. 我们在这里覆盖了 `channelRead()` 事件处理程序方法。每当从客户端接收到新数据时，都会使用接收到的消息调用此方法。本例中，接收消息的类型为`ByteBuf`。
3. 要实现 DISCARD 协议，处理程序必须忽略接收到的消息。`ByteBuf` 是一个引用计数对象，它必须通过 `release()` 方法显式释放。请记住，释放任何传递给处理程序的引用计数对象是处理程序的责任。通常，`channelRead()` 处理程序方法的实现方式如下：

```java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    try {
        // Do something with msg
    } finally {
        ReferenceCountUtil.release(msg);
    }
}
```

4. 当 Netty 由于 I/O 错误或处理程序实现由于处理事件时抛出的异常而引发异常时，将使用 `Throwable` 调用 `exceptionCaught()` 事件处理程序方法。在大多数情况下，应该记录捕获的异常并在此处关闭其关联的`channel`，尽管此方法的实现可能会有所不同，具体取决于您要做什么来处理异常情况。例如，您可能希望在关闭连接之前发送带有错误代码的响应消息。

到现在为止还挺好。我们已经实现了 DISCARD 服务器的前半部分。现在剩下的是编写 `main()` 方法使用`DiscardServer`启动服务器。

```java
package io.netty.example.discard;
    
import io.netty.bootstrap.ServerBootstrap;

import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
    
/**
 * 丢弃任何到来的数据
 */
public class DiscardServer {
    
    private int port;
    
    public DiscardServer(int port) {
        this.port = port;
    }
    
    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(); // (1)
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap(); // (2)
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class) // (3)
             .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ch.pipeline().addLast(new DiscardServerHandler());
                 }
             })
             .option(ChannelOption.SO_BACKLOG, 128)          // (5)
             .childOption(ChannelOption.SO_KEEPALIVE, true); // (6)
    
            // 绑定并开始接受到来的连接
            ChannelFuture f = b.bind(port).sync(); // (7)
    
            // 阻塞直到服务器Socket被关闭
            // 在本例中，这不会发生， 但是你可以优雅的去这样处理
            // 关闭服务器
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
    
    public static void main(String[] args) throws Exception {
        int port = 8080;
        if (args.length > 0) {
            port = Integer.parseInt(args[0]);
        }

        new DiscardServer(port).run();
    }
}
```

1. [NioEventLoopGroup](https://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html) 是一个处理 I/O 操作的多线程事件循环。Netty 为不同类型的传输提供了各种 [EventLoopGroup](https://netty.io/4.1/api/io/netty/channel/EventLoopGroup.html) 实现。我们在这个例子中实现了一个服务器端应用程序，因此将使用两个 `NioEventLoopGroup`。第一个，通常称为“老板”，接受到来的连接。第二个，通常称为“工人”，一旦“老板”接受到连接并将接受到的连接注册到“工人”，就会处理已接受连接的流量。使用多少线程以及它们如何映射到创建的 `Channels` 取决于 `EventLoopGroup` 实现，甚至可以通过构造函数进行配置。
2. [ServerBootstrap](https://netty.io/4.1/api/io/netty/bootstrap/ServerBootstrap.html) 是一个设置服务器的辅助类。您可以直接使用 Channel 设置服务器。但是，请注意，这是一个繁琐的过程，在大多数情况下您不需要这样做。
3. 在这里，我们指定使用 [NioServerSocketChannel](https://netty.io/4.1/api/io/netty/channel/socket/nio/NioServerSocketChannel.html) 类，该类用于实例化新 Channel 以接受到来的连接。
4. 此处指定的处理程序将始终会处理新接受到的[Channel](https://netty.io/4.1/api/io/netty/channel/Channel.html) 。[ChannelInitializer](https://netty.io/4.1/api/io/netty/channel/ChannelInitializer.html) 是一个特殊的处理程序，旨在帮助用户配置新的 Channel。最有可能的是您想要通过添加一些处理程序（例如 DiscardServerHandler）来配置新 Channel 的 [ChannelPipeline](https://netty.io/4.1/api/io/netty/channel/ChannelPipeline.html) 来实现您的网络应用程序。随着应用程序变得复杂，您可能会向 ChannelPipeline 中添加更多的处理程序，并最终将此匿名类提取成顶级类。
5. 您还可以设置特定于 Channel 实现的参数。我们正在编写一个 TCP/IP 服务器，因此我们可以设置Socket选项，例如 `tcpNoDelay` 和 `keepAlive`。请参阅 [ChannelOption](https://netty.io/4.1/api/io/netty/channel/ChannelOption.html) 的 apidocs和特定的 [ChannelConfig](https://netty.io/4.1/api/io/netty/channel/ChannelConfig.html) 实现以获取有关支持的 ChannelOptions 的概述。
6. 你注意到 `option()` 和 `childOption()` 了吗？`option()` 用于接受到来了的连接的 `NioServerSocketChannel`。`childOption()` 用于父 [ServerChannel](https://netty.io/4.1/api/io/netty/channel/ServerChannel.html) 接受的 Channels，在本例中为 [NioSocketChannel](https://netty.io/4.1/api/io/netty/channel/socket/nio/NioSocketChannel.html)。
7. 我们现在准备好了。剩下的就是绑定到端口并启动服务器。我们绑定到机器中所有网卡（network interface cards）的8080端口。您现在可以根据需要多次调用 bind() 方法（使用不同的绑定地址。）

恭喜！ 您刚刚使用 Netty 完成了您的第一台服务器。

### 查看接收到的消息

现在我们已经编写了我们的第一个服务器，我们需要测试它是否真的有效。测试它的最简单方法是使用 `telnet` 命令。例如，您可以在命令行中输入 `telnet localhost 8080` 然后输入一些内容。

但是，我们可以说服务器运行良好吗？我们无法真正知道，因为它是丢弃服务器。你根本不会得到任何响应。为了证明它确实有效，让我们修改服务器以打印它收到的内容。

我们已经知道只要接收到数据就会调用 `channelRead()` 方法。让我们在 `DiscardServerHandler` 的 `channelRead()` 方法中写一些代码：

```java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf in = (ByteBuf) msg;
    try {
        while (in.isReadable()) { // (1)
            System.out.print((char) in.readByte());
            System.out.flush();
        }
    } finally {
        ReferenceCountUtil.release(msg); // (2)
    }
}
```

1. 这个低效率的循环实际上可以被简化为：

```java
System.out.println(in.toString(io.netty.util.CharsetUtil.US_ASCII));
```

2. 或者，您可以在此处执行 `in.release()` 。

如果您再次运行 telnet 命令，您将看到服务器打印它收到的内容。

`DiscardServer`的完整源代码位于发行版的 [io.netty.example.discard](https://netty.io/4.1/xref/io/netty/example/discard/package-summary.html) 包中。

### 编写一个ECHO服务器

到目前为止，我们一直在消费数据而根本没有响应。然而，服务器通常应该对请求作出响应。让我们学习如何通过实现 ECHO 协议向客户端写入响应消息，将收到的任何消息返回给客户端。

与我们在前几节中实现的 `DiscardServer` 的唯一区别是它将接收到的数据发送回客户端而不是将接收到的数据打印到控制台。因此，再次修改 channelRead() 方法就足够了：

```java
@Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ctx.write(msg); // (1)
        ctx.flush(); // (2)
    }
```

1. `ChannelHandlerContext` 对象提供各种操作，使您能够触发各种 I/O 事件和操作。在这里，我们调用 `write(Object)` 逐字向客户端返回接收到的消息。请注意，我们没有像在 DISCARD 示例中那样释放收到的消息。这是因为当它被写回时，Netty 会为你释放它。
2. `ctx.write(Object)` 不会将消息立即写回给客户端。它在内部进行缓冲，然后通过 `ctx.flush()` 刷新写回客户端。或者，为了简洁起见，您可以调用 `ctx.writeAndFlush(msg)`。

如果您再次运行 telnet 命令，您将看到服务器将您发送给它的任何内容发回给您。回文服务器的完整源代码位于发行版的 [io.netty.example.echo](https://netty.io/4.1/xref/io/netty/example/echo/package-summary.html) 包中。

### 编写一个TIME服务器

本节要实现的协议是 TIME 协议。它与前面的例子不同，一旦发送一条包含一个 32 位整数的消息之后，不接收任何的消息就会关闭连接。在此示例中，您将学习如何构造和发送消息，以及如何在完成时关闭连接。

因为我们将忽略任何接收到的数据，而是在建立连接后立即发送消息，所以这次我们不能使用 `channelRead()` 方法。取而代之的是，们应该重写 `channelActive()` 方法。下面是实现：

```java
package io.netty.example.time;

public class TimeServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelActive(final ChannelHandlerContext ctx) { // (1)
        final ByteBuf time = ctx.alloc().buffer(4); // (2)
        time.writeInt((int) (System.currentTimeMillis() / 1000L + 2208988800L));
        
        final ChannelFuture f = ctx.writeAndFlush(time); // (3)
        f.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                assert f == future;
                ctx.close();
            }
        }); // (4)
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
```

1. 如前所述，当建立连接并准备好生成信息流量时，将调用 `channelActive()` 方法。让我们在这个方法中写一个 32 位整数来表示当前时间。
2. 要发送新消息，我们需要分配一个新的 buffer 来包含该消息。我们将要写入一个 32 位整数，因此我们需要一个容量至少为 4 个字节的 [ByteBuf](https://netty.io/4.1/api/io/netty/buffer/ByteBuf.html)。通过 `ChannelHandlerContext.alloc()` 获取当前的 [ByteBufAllocator](https://netty.io/4.1/api/io/netty/buffer/ByteBufAllocator.html) 并分配一个新的 buffer。
3. 像往常一样，我们编写构造的消息。

但是等等，`flip` 在哪里？之前我们不是在 NIO 中发送消息之前调用 `java.nio.ByteBuffer.flip()` 吗？ByteBuf 没有这样的方法，因为它有两个指针；一个用于读操作，另一个用于写操作。当您向 ByteBuf 写入内容而读索引不会更改时，写索引会增加。读索引和写索引分别表示消息开始和结束的位置。

相比之下，NIO buffer 没有提供一种干净的方法来确定消息内容的开始和结束位置，而无需调用 `flip` 方法。当您忘记翻转 buffer 时，您会遇到问题，因为不会发送任何数据或发送的是不正确的数据。这种错误在 Netty 中不会发生，因为我们针对不同的操作类型有不同的指针。你会发现它会让你的生活变得更轻松。

另一点要注意的是 `ChannelHandlerContext.write()`（和 `writeAndFlush()`）方法返回一个 [ChannelFuture](https://netty.io/4.1/api/io/netty/channel/ChannelFuture.html)。`ChannelFuture` 表示尚未发生的 I/O 操作。这意味着，任何请求的操作可能尚未执行，因为所有操作在 Netty 中都是异步的。例如，以下代码甚至可能在发送消息之前关闭连接：

```java
Channel ch = ...;
ch.writeAndFlush(message);
ch.close();
```

因此，您需要在 `ChannelFuture` 完成后调用 `close()` 方法，`ChannelFuture`由 `write()` 方法返回，并在写入操作完成时通知其侦听器。请注意，`close()` 也可能不会立即关闭连接，它会返回一个 `ChannelFuture`。

4. 那么当写请求完成时我们如何得到通知？它是非常的简单，直接将 [ChannelFutureListener](https://netty.io/4.1/api/io/netty/channel/ChannelFutureListener.html) 添加到返回的 `ChannelFuture`就可以了。在这里，我们创建了一个新的匿名 `ChannelFutureListener`，它在操作完成时关闭 `Channel`。

或者，你可以使用预先定义好的 `listener`去简化代码：

```java
f.addListener(ChannelFutureListener.CLOSE);
```

要测试我们的 TIME 服务器是否按预期工作，您可以使用 UNIX rdate 命令：

```bash
$ rdate -o <port> -p <host>
```

其中 `<port>` 是您在 `main()` 方法中指定的端口号，`<host>` 通常是 `localhost`。

